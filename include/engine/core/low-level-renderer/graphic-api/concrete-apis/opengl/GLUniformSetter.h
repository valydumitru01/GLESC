/**************************************************************************************************
 * @file   GLUniformSetter.h
 * @author Valentin Dumitru
 * @date   2023-11-17
 * @brief  Add description of this file if needed @TODO 
 *
 * Copyright (c) 2023 Valentin Dumitru. Licensed under the MIT License.
 * See LICENSE.txt in the project root for license information.
 **************************************************************************************************/
#pragma once

#include <engine/core/exceptions/core/low-level-renderer/GAPIException.h>
#include "engine/core/low-level-renderer/graphic-api/IUniformSetter.h"
#include "engine/core/low-level-renderer/graphic-api/GapiTypes.h"

class GLUniformSetter : public IUniformSetter {
public:
    GLUniformSetter(GAPIuint program, const std::string& uName) {
        // First, check if the program is a valid program generated by OpenGL
        if (!glIsProgram(program)) {
            throw GAPIException("Can't set uniform, shader program is invalid");
        }
        // Get the location of the uniform
        GAPIint tempLocation = glGetUniformLocation(program, uName.c_str());
        
        // Check if the uniform location was found
        if (tempLocation == -1) {
            throw GAPIException("Can't set uniform, uniform " + uName + " not found");
        }
        
        this->location = tempLocation;
    }
    
    // Implement single value setters
    inline void u1F(GAPIfloat v0) override {
        glUniform1f(location, v0);
    }
    
    inline void u1I(GAPIint v0) override {
        glUniform1i(location, v0);
    }
    
    inline void u1Ui(GAPIuint v0) override {
        glUniform1ui(location, v0);
    }
    
    inline void u1B(GAPIbool v0) override {
        glUniform1i(location, static_cast<GAPIint>(v0));
    }
    
    
    // Single vectors
    // Floats
    inline void u2F(Vec2F vec2) override {
        glUniform2f(location, vec2.x(), vec2.y());
    }
    
    inline void u3F(Vec3F vec3) override {
        glUniform3f(location, vec3.x(), vec3.y(), vec3.z());
    }
    
    inline void u4F(Vec4F vec4) override {
        glUniform4f(location, vec4.x(), vec4.y(), vec4.z(), vec4.w());
    }
    
    inline void u2F(GAPIfloat vec2[2]) override {
        glUniform2f(location, vec2[0], vec2[1]);
    }
    
    inline void u3F(GAPIfloat vec3[3]) override {
        glUniform3f(location, vec3[0], vec3[1], vec3[2]);
    }
    
    inline void u4F(GAPIfloat vec4[4]) override {
        glUniform4f(location, vec4[0], vec4[1], vec4[2], vec4[3]);
    }
    
    inline void u2F(GAPIfloat v0, GAPIfloat v1) override {
        glUniform2f(location, v0, v1);
    }
    
    inline void u3F(GAPIfloat v0, GAPIfloat v1, GAPIfloat v2) override {
        glUniform3f(location, v0, v1, v2);
    }
    
    inline void u4F(GAPIfloat v0, GAPIfloat v1, GAPIfloat v2, GAPIfloat v3) override {
        glUniform4f(location, v0, v1, v2, v3);
    }
    
    // Ints
    inline void u2I(Vec2I vec2) override {
        glUniform2i(location, vec2.x(), vec2.y());
    }
    
    inline void u3I(Vec3I vec3) override {
        glUniform3i(location, vec3.x(), vec3.y(), vec3.z());
    }
    
    inline void u4I(Vec4I vec4) override {
        glUniform4i(location, vec4.x(), vec4.y(), vec4.z(), vec4.w());
    }
    
    inline void u2I(GAPIint vec2[2]) override {
        glUniform2i(location, vec2[0], vec2[1]);
    }
    
    inline void u3I(GAPIint vec3[3]) override {
        glUniform3i(location, vec3[0], vec3[1], vec3[2]);
    }
    
    inline void u4I(GAPIint vec4[4]) override {
        glUniform4i(location, vec4[0], vec4[1], vec4[2], vec4[3]);
    }
    
    inline void u2I(GAPIint v0, GAPIint v1) override {
        glUniform2i(location, v0, v1);
    }
    
    inline void u3I(GAPIint v0, GAPIint v1, GAPIint v2) override {
        glUniform3i(location, v0, v1, v2);
    }
    
    inline void u4I(GAPIint v0, GAPIint v1, GAPIint v2, GAPIint v3) override {
        glUniform4i(location, v0, v1, v2, v3);
    }
    
    // Unsigned ints
    inline void u2Ui(Vec2Ui vec2) override {
        glUniform2ui(location, vec2.x(), vec2.y());
    }
    
    inline void u3Ui(Vec3Ui vec3) override {
        glUniform3ui(location, vec3.x(), vec3.y(), vec3.z());
    }
    
    inline void u4Ui(Vec4Ui vec4) override {
        glUniform4ui(location, vec4.x(), vec4.y(), vec4.z(), vec4.w());
    }
    
    inline void u2Ui(GAPIuint vec2[2]) override {
        glUniform2ui(location, vec2[0], vec2[1]);
    }
    
    inline void u3Ui(GAPIuint vec3[3]) override {
        glUniform3ui(location, vec3[0], vec3[1], vec3[2]);
    }
    
    inline void u4Ui(GAPIuint vec4[4]) override {
        glUniform4ui(location, vec4[0], vec4[1], vec4[2], vec4[3]);
    }
    
    inline void u2Ui(GAPIuint v0, GAPIuint v1) override {
        glUniform2ui(location, v0, v1);
    }
    
    inline void u3Ui(GAPIuint v0, GAPIuint v1, GAPIuint v2) override {
        glUniform3ui(location, v0, v1, v2);
    }
    
    inline void u4Ui(GAPIuint v0, GAPIuint v1, GAPIuint v2, GAPIuint v3) override {
        glUniform4ui(location, v0, v1, v2, v3);
    }
    
    // Booleans
    inline void u2B(Vec2B vec2) override {
        glUniform2i(location, static_cast<GAPIint>(vec2.x()),
                    static_cast<GAPIint>(vec2.y()));
    }
    
    inline void u3B(Vec3B vec3) override {
        glUniform3i(location, static_cast<GAPIint>(vec3.x()),
                    static_cast<GAPIint>(vec3.y()),
                    static_cast<GAPIint>(vec3.z()));
    }
    
    inline void u4B(Vec4B vec4) override {
        glUniform4i(location, static_cast<GAPIint>(vec4.x()),
                    static_cast<GAPIint>(vec4.y()),
                    static_cast<GAPIint>(vec4.z()), static_cast<GAPIint>(vec4.w()));
    }
    
    inline void u2B(GAPIbool vec2[2]) override {
        glUniform2i(location, static_cast<GAPIint>(vec2[0]), static_cast<GAPIint>(vec2[1]));
    }
    
    inline void u3B(GAPIbool vec3[3]) override {
        glUniform3i(location, static_cast<GAPIint>(vec3[0]), static_cast<GAPIint>(vec3[1]),
                    static_cast<GAPIint>(vec3[2]));
    }
    
    inline void u4B(GAPIbool vec4[4]) override {
        glUniform4i(location, static_cast<GAPIint>(vec4[0]), static_cast<GAPIint>(vec4[1]),
                    static_cast<GAPIint>(vec4[2]), static_cast<GAPIint>(vec4[3]));
    }
    
    inline void u2B(GAPIbool v0, GAPIbool v1) override {
        glUniform2i(location, static_cast<GAPIint>(v0), static_cast<GAPIint>(v1));
    }
    
    inline void u3B(GAPIbool v0, GAPIbool v1, GAPIbool v2) override {
        glUniform3i(location, static_cast<GAPIint>(v0), static_cast<GAPIint>(v1),
                    static_cast<GAPIint>(v2));
    }
    
    inline void u4B(GAPIbool v0, GAPIbool v1, GAPIbool v2, GAPIbool v3) override {
        glUniform4i(location, static_cast<GAPIint>(v0), static_cast<GAPIint>(v1),
                    static_cast<GAPIint>(v2), static_cast<GAPIint>(v3));
    }
    
    
    // Single matrices
    // Floats
    inline void uMat2F(Mat2F mat) override {
        glUniformMatrix2fv(location, 1, GL_FALSE, &mat[0][0]);
    }
    
    inline void uMat3F(Mat3F mat) override {
        glUniformMatrix3fv(location, 1, GL_FALSE, &mat[0][0]);
    }
    
    inline void uMat4F(Mat4F mat) override {
        glUniformMatrix4fv(location, 1, GL_FALSE, &mat[0][0]);
    }
    
    // Vectors of vectors
    // Floats
    inline void u1FVec(const std::vector<GAPIfloat> &values) override {
        glUniform1fv(location, static_cast<GLsizei>(values.size()), values.data());
    }
    
    inline void u2FVec(const std::vector<Vec2F> &values) override {
        glUniform2fv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLfloat *>(values.data()));
    }
    
    inline void u3FVec(const std::vector<Vec3F> &values) override {
        glUniform3fv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLfloat *>(values.data()));
    }
    
    inline void u4FVec(const std::vector<Vec4F> &values) override {
        glUniform4fv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLfloat *>(values.data()));
    }
    
    // Ints
    inline void u1IVec(const std::vector<GAPIint> &values) override {
        glUniform1iv(location, static_cast<GLsizei>(values.size()), values.data());
    }
    
    inline void u2IVec(const std::vector<Vec2I> &values) override {
        glUniform2iv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLint *>(values.data()));
    }
    
    inline void u3IVec(const std::vector<Vec3I> &values) override {
        glUniform3iv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLint *>(values.data()));
    }
    
    inline void u4IVec(const std::vector<Vec4I> &values) override {
        glUniform4iv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLint *>(values.data()));
    }
    
    // Unsigned ints
    inline void u1UiVec(const std::vector<GAPIuint> &values) override {
        glUniform1uiv(location, static_cast<GLsizei>(values.size()), values.data());
    }
    
    inline void u2UiVec(const std::vector<Vec2Ui> &values) override {
        glUniform2uiv(location, static_cast<GLsizei>(values.size()),
                      reinterpret_cast<const GLuint *>(values.data()));
    }
    
    inline void u3UiVec(const std::vector<Vec3Ui> &values) override {
        glUniform3uiv(location, static_cast<GLsizei>(values.size()),
                      reinterpret_cast<const GLuint *>(values.data()));
    }
    
    inline void u4UiVec(const std::vector<Vec4Ui> &values) override {
        glUniform4uiv(location, static_cast<GLsizei>(values.size()),
                      reinterpret_cast<const GLuint *>(values.data()));
    }
    
    // Booleans
    inline void u1BVec(const std::vector<GAPIbool> &values) override {
        glUniform1iv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLint *>(values.data()));
    }
    
    inline void u2BVec(const std::vector<Vec2B> &values) override {
        glUniform2iv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLint *>(values.data()));
    }
    
    inline void u3BVec(const std::vector<Vec3B> &values) override {
        glUniform3iv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLint *>(values.data()));
    }
    
    inline void u4BVec(const std::vector<Vec4B> &values) override {
        glUniform4iv(location, static_cast<GLsizei>(values.size()),
                     reinterpret_cast<const GLint *>(values.data()));
    }
    
    
    // Multiple matrices
    inline void uMat2FVec(const std::vector<Mat2F> &mats) override {
        glUniformMatrix2fv(location, static_cast<GLsizei>(mats.size()), GL_FALSE,
                           reinterpret_cast<const GLfloat *>(mats.data()));
    }
    
    inline void uMat3FVec(const std::vector<Mat3F> &mats) override {
        glUniformMatrix3fv(location, static_cast<GLsizei>(mats.size()), GL_FALSE,
                           reinterpret_cast<const GLfloat *>(mats.data()));
    }
    
    inline void uMat4FVec(const std::vector<Mat4F> &mats) override {
        glUniformMatrix4fv(location, static_cast<GLsizei>(mats.size()), GL_FALSE,
                           reinterpret_cast<const GLfloat *>(mats.data()));
    }


private:


    GAPIint location;
};